# LibreVNA Per-Point Timestamp Capability Evaluation

**Date:** 2026-02-11
**Objective:** Evaluate whether LibreVNA has dedicated SCPI commands for generating timestamps of each frequency point during sweeping tests
**Reference Data:** `Dataflux.csv` (Keysight E5063A marker polling log)

---

## Executive Summary

**Key Finding:** LibreVNA has **NO dedicated SCPI command, streaming field, or protocol mechanism** for per-point timestamps at any layer (SCPI queries, streaming JSON, or USB binary protocol).

**Recommended Solution:** Implement host-side timestamping in the streaming callback (Alternative A) for per-point timestamp capture with ~1ms accuracy.

---

## 1. Dataflux.csv Data Format Analysis

### 1.1 Source Instrument
- **VNA Model:** Keysight E5063A (Serial: MY54806798)
- **Application:** VNA-DATAFLUX
- **Data Type:** Marker polling log (**NOT** a full sweep dump)

### 1.2 File Structure

**Header Section (lines 1-14):**
```
Application,VNA-DATAFLUX
VNA Model,E5063A
VNA Serial,MY54806798
Start DateTime,2026/02/10 14:36:09
Number of Data,1800
Log Interval(ms),20
Freq Start(MHz),223.0
Freq Stop(MHz),243.0
IF Bandwidth(KHz),70.0
Points,801
```

**Data Section (lines 16-1815) - Three Columns:**
| Column | Format | Example |
|--------|--------|---------|
| Time | `HH:MM:SS.microseconds` | `14:36:10.013396` |
| Marker Stimulus (Hz) | Scientific notation | `+2.33500000000E+008` (233.5 MHz) |
| Marker Y Real Value (dB) | Scientific notation | `-9.86725508332E+000` (-9.867 dB) |

### 1.3 Data Characteristics

- **Sampling Method:** Single marker value polled at ~20ms intervals
- **Total Duration:** ~41.8 seconds (14:36:10.013 to 14:36:51.819)
- **Total Readings:** 1800 samples
- **Actual Interval:** ~23.2 ms average (vs. target 20ms)
- **Marker Frequency Range:** 233.45 - 233.80 MHz (slight wandering, likely peak-tracking marker)
- **Amplitude Stability:** ~-9.85 dB (very stable, consistent with matched-load measurement)

### 1.4 Critical Insight

**The timestamps are generated by the HOST APPLICATION, not the VNA instrument itself.** This is a software-level feature of VNA-DATAFLUX, not a hardware capability of the E5063A.

---

## 2. LibreVNA Timestamp Capability Assessment

### 2.1 SCPI Command Review

Exhaustive review of all LibreVNA SCPI commands related to timing/data acquisition:

| SCPI Command | Return Value | Per-Point Timestamp? |
|--------------|--------------|---------------------|
| `VNA:ACQ:TIME?` | Current sweep elapsed time (seconds) | ❌ **Zero-span mode only**. Single value, not per-point |
| `VNA:ACQ:FREQuency?` | Current sweep frequency (Hz) | ❌ Position only, no timing |
| `VNA:TRACe:DATA? <trace>` | Array of `[freq, real, imag]` tuples | ❌ **No timestamp field** |
| `VNA:TRACe:AT? <trace> <freq>` | `real, imag` at one frequency | ❌ Single-point query, no timestamp |
| `VNA:TRACe:TOUCHSTONE?` | Standard Touchstone format | ❌ Format has no timestamp capability |
| `VNA:ACQ:FINished?` | `TRUE` / `FALSE` | ❌ Completion flag only |

**Verdict:** No SCPI command exists for per-point timestamp generation.

### 2.2 Streaming Server JSON Format (Ports 19000-19002)

Example streaming JSON object per point:
```json
{
  "pointNum": 0,
  "frequency": 2430000000,
  "Z0": 50.0,
  "measurements": {
    "S11_real": -0.123,
    "S11_imag": 0.045
  }
}
```

**Available Fields:** `pointNum`, `frequency`, `Z0`, `measurements`
**Missing Field:** ❌ **No `timestamp` key**

Reference: `libreVNA.py` lines 153-178 (`__live_thread` streaming parser)

### 2.3 USB Direct Protocol (VNADatapoint, Type 27)

Binary payload structure:
- Frequency (8 bytes, UINT64)
- PowerLevel (2 bytes, INT16)
- PointNumber (2 bytes, UINT16)
- Real/Imag receiver arrays
- Bitmask descriptors

**Verdict:** ❌ **No timestamp field in binary protocol**

Reference: `USB_protocol_v12.pdf`, `Device_protocol_v13.pdf`

---

## 3. Available Alternatives for Per-Point Timestamping

### Alternative A: Host-Side Timestamp in Streaming Callback ✅ **RECOMMENDED**

**Implementation Pattern:**
```python
def streaming_callback(data):
    point_time = time.time()  # or datetime.now()
    point_num  = data["pointNum"]
    frequency  = data["frequency"]
    s11        = data["measurements"]["S11"]

    # Log: point_time, frequency, s11
```

**Characteristics:**
- **Resolution:** Microsecond on Linux (~1ms practical on Windows)
- **Accuracy Limitation:** Timestamp records when host *received* data, not when instrument *measured* it (~1-5ms transport delay)
- **Throughput:** ~5,100 timestamped points/second (300 points @ 17Hz continuous mode)
- **Implementation Effort:** ✅ Low - extend existing scripts 5/6 callback

**Existing Implementation Reference:**
- `5_continuous_sweep_speed.py` - Already timestamps sweep boundaries (`pointNum == 0`)
- `6_librevna_gui_mode_sweep_test.py` - ContinuousModeSweep class with streaming callback

**Pros:**
- ✅ Already architecturally supported in codebase
- ✅ Captures **ALL sweep points** (not just one marker like Dataflux)
- ✅ High data density (~100x richer than Dataflux 50Hz marker polling)
- ✅ Minimal code changes required

**Cons:**
- ⚠️ Timestamps reflect host receipt time, not instrument measurement time
- ⚠️ 1-5ms variable latency (USB transfer + GUI processing + TCP push)

---

### Alternative B: Host-Side Marker Emulation via SCPI Polling

**Implementation Pattern:**
```python
target_freq = 2.435e9  # 2.435 GHz
poll_interval = 0.02   # 20ms

while running:
    timestamp = datetime.now()
    response = vna.query(f"VNA:TRACe:AT? S11 {target_freq}")
    real, imag = parse_response(response)

    # Log: timestamp, target_freq, real, imag
    time.sleep(poll_interval)
```

**Characteristics:**
- **Achievable Rate:** 20-50ms per query (SCPI round-trip over TCP localhost)
- **Compatibility:** ✅ Directly replicates Dataflux "poll one marker" paradigm
- **Implementation Effort:** ✅ Low - simple polling loop

**Pros:**
- ✅ Closest behavioral match to Dataflux CSV pattern
- ✅ Simple implementation

**Cons:**
- ⚠️ SCPI round-trip jitter (1-5ms) makes interval less uniform than Dataflux
- ⚠️ Only one frequency point per query (discards rest of sweep data)
- ⚠️ Wasteful - VNA still performs full sweep but only one point is captured

---

### Alternative C: Per-Sweep Bulk Timestamp with Interpolation

**Implementation Pattern:**
```python
sweep_start = time.time()
vna.cmd("VNA:ACQ:RUN")
# Wait for sweep completion
sweep_end = time.time()

trace_data = vna.query("VNA:TRACe:DATA? S11")
sweep_duration = sweep_end - sweep_start
num_points = len(trace_data)

# Interpolate per-point timestamps
for n, point in enumerate(trace_data):
    point_time = sweep_start + n * (sweep_duration / num_points)
```

**Characteristics:**
- **Accuracy:** Model-based (depends on knowing actual sweep duration)
- **Implementation Effort:** ⚠️ Medium - requires sweep-rate calibration model

**Pros:**
- ✅ Deterministic per-point timing (with proper calibration)
- ✅ Works with single-sweep mode

**Cons:**
- ⚠️ Interpolated timestamps, not measured timestamps
- ⚠️ Requires calibrating sweep-rate model for different IFBW/point combinations
- ⚠️ Not suitable if precise per-point timing is critical

---

### Alternative D: USB Direct Protocol with Host Timestamps

**Implementation Pattern:**
```python
# USB bulk read loop
while True:
    packet = usb_device.read(endpoint_in)
    timestamp = time.time()

    vna_datapoint = parse_vna_datapoint(packet)
    # Log: timestamp, frequency, raw_receiver_data
```

**Characteristics:**
- **Latency:** Lowest (bypasses GUI middleware, TCP layer, JSON serialization)
- **Jitter:** Best (USB bulk transfers more predictable than TCP)
- **Throughput:** ~9,900 timestamped points/second (300 points @ 33Hz)
- **Implementation Effort:** ❌ High - requires full USB protocol stack

**Pros:**
- ✅ Lowest latency path
- ✅ Best timestamp jitter performance
- ✅ Highest throughput potential

**Cons:**
- ❌ Requires implementing USB protocol stack, CRC handling, S-parameter assembly
- ❌ No calibration applied by firmware (host must apply cal data)
- ❌ Not yet implemented in codebase
- ❌ Reference implementation: `markdown/20260205/part2-continuous-sweep-implementation.md` §7.11

---

## 4. Feasibility Comparison Matrix

| Approach | Feasibility | Fidelity vs. Dataflux | Effort | Status |
|----------|------------|----------------------|--------|---------|
| **A: Streaming callback + host timestamp** | ✅ High | Higher (all points) | Low | Partially implemented |
| **B: SCPI marker polling** | ⚠️ Medium | Closest match | Low | Not implemented |
| **C: Bulk read + interpolation** | ⚠️ Medium | Lower (interpolated) | Medium | Not implemented |
| **D: USB direct + host timestamp** | ✅ High (theoretical) | Highest (lowest jitter) | High | Not implemented |

---

## 5. Recommendations

### 5.1 Immediate Implementation (Phase 1)

**Use Alternative A: Streaming Callback with Host-Side Timestamps**

**Rationale:**
1. Already architecturally supported (scripts 5 and 6 demonstrate pattern)
2. Minimal code changes required
3. Provides **all sweep points** with ~1ms timestamp accuracy
4. Delivers 100x more data density than Dataflux marker polling

**Implementation Steps:**
1. Extend existing `ContinuousModeSweep` streaming callback in `6_librevna_gui_mode_sweep_test.py`
2. Add `timestamp = time.time()` or `datetime.now()` in callback
3. Modify data export to include timestamp column
4. Test timestamp resolution and jitter on target platform

**Expected Output Format (CSV):**
```csv
Timestamp,Frequency_Hz,S11_dB,S11_Phase_deg
2026-02-11T15:30:45.123456,2430000000,-12.34,45.67
2026-02-11T15:30:45.123789,2430666666,-12.35,45.68
...
```

### 5.2 Future Enhancement (Phase 2)

**Evaluate Alternative D: USB Direct Protocol**

**Rationale:**
- Best timestamp jitter performance
- Highest theoretical throughput (~33Hz sweep rate)
- Eliminates all middleware latency

**Prerequisites:**
- Complete USB protocol implementation (see `USB_protocol_v12.pdf`)
- Implement S-parameter assembly from raw receiver data
- Apply calibration data on host side

**Estimated Effort:** 2-4 weeks for full implementation

---

## 6. Technical Constraints and Caveats

### 6.1 Host-Side Timestamping Accuracy

All alternatives rely on **host-side timestamps**, which have inherent limitations:

**Latency Sources (Alternative A):**
1. Firmware ADC capture → USB transfer: ~0.1-0.5ms
2. LibreVNA-GUI processing: ~0.5-2ms
3. TCP localhost push: ~0.1-0.5ms
4. Python callback invocation: ~0.1-1ms

**Total variable delay:** ~1-5ms between measurement and timestamp

**Implication:** Timestamps represent **data receipt time**, not **measurement time**. For applications requiring true measurement timestamps, firmware-level timestamping would be required (not available in LibreVNA).

### 6.2 Timestamp Resolution by Platform

| Platform | `time.time()` Resolution | Practical Accuracy |
|----------|-------------------------|-------------------|
| Linux | Nanosecond | ~1 microsecond |
| Windows | Microsecond | ~1 millisecond (15.6ms timer granularity) |
| macOS | Microsecond | ~1 microsecond |

**Note:** Use `time.perf_counter()` for higher resolution interval measurement (not wall-clock time).

### 6.3 Streaming Callback Thread Context

The streaming callback in `libreVNA.py` runs on a **background thread** (line 148: `threading.Thread(target=self.__live_thread)`). When adding timestamping:
- `time.time()` is thread-safe
- `datetime.now()` is thread-safe
- File I/O should use thread-safe buffering or queue patterns

---

## 7. Comparison with Dataflux Capability

### 7.1 Data Density

| System | Points/Second | Coverage |
|--------|--------------|----------|
| **Dataflux (E5063A)** | ~50 | Single marker only |
| **LibreVNA Alternative A** | ~5,100 | All 300 sweep points |
| **LibreVNA Alternative D** | ~9,900 | All 300 sweep points |

LibreVNA streaming provides **100x-200x more data density** than Dataflux marker polling.

### 7.2 Timestamp Source

| System | Timestamp Source | Accuracy |
|--------|-----------------|----------|
| **Dataflux (E5063A)** | Host application | Receipt time (~1ms) |
| **LibreVNA All Alternatives** | Host application | Receipt time (~1-5ms) |

**Key insight:** Even the Dataflux reference uses host-side timestamps, not instrument-generated timestamps.

---

## 8. Next Steps

### 8.1 Proof of Concept (PoC)

1. ✅ Create timestamped sweep script based on Alternative A
2. ✅ Benchmark timestamp jitter on Windows vs. Linux
3. ✅ Compare timestamp accuracy against known signal source
4. ✅ Generate sample CSV output matching Dataflux format

### 8.2 Production Implementation

1. ✅ Integrate into script 6 (`6_librevna_gui_mode_sweep_test.py`)
2. ✅ Add timestamp column to XLSX export
3. ✅ Update GUI (script 7) to display timestamped data
4. ✅ Document timestamp accuracy limitations in user guide

### 8.3 Long-Term Research

1. ⚠️ Investigate USB direct protocol implementation (Alternative D)
2. ⚠️ Measure actual transport latency (firmware → host callback)
3. ⚠️ Evaluate firmware modification feasibility for true measurement timestamps
4. ⚠️ Consider submitting feature request to LibreVNA project for firmware timestamping

---

## 9. References

### 9.1 Source Code Files
- `code/LibreVNA-dev/scripts/libreVNA.py` - SCPI wrapper with streaming callback (lines 148-178)
- `code/LibreVNA-dev/scripts/5_continuous_sweep_speed.py` - Streaming callback implementation
- `code/LibreVNA-dev/scripts/6_librevna_gui_mode_sweep_test.py` - ContinuousModeSweep class
- `code/LibreVNA-dev/gui/mvp/backend_wrapper.py` - GUI adapter with streaming integration

### 9.2 Documentation
- `USB_protocol_v12.pdf` - USB bulk transfer protocol specification
- `Device_protocol_v13.pdf` - VNADatapoint binary format (Type 27)
- `markdown/20260205/part2-continuous-sweep-implementation.md` §7.11 - USB protocol summary

### 9.3 Related SCPI Commands
- `VNA:ACQ:TIME?` - Zero-span mode timing query
- `VNA:TRACe:DATA? <trace>` - Bulk sweep data retrieval
- `VNA:TRACe:AT? <trace> <freq>` - Single-point query
- `:DEV:PREF StreamingServers.VNACalibratedData.enabled true` - Enable streaming server

### 9.4 External References
- Python `time.time()` documentation: https://docs.python.org/3/library/time.html#time.time
- Python `datetime.now()` documentation: https://docs.python.org/3/library/datetime.html#datetime.datetime.now
- LibreVNA-GUI project: https://github.com/jankae/LibreVNA

---

## 10. Conclusion

**LibreVNA does not provide native per-point timestamping capability** at any protocol layer (SCPI, streaming JSON, or USB binary). However, **host-side timestamping in the streaming callback** (Alternative A) provides a practical solution that:

✅ Delivers all sweep points with ~1ms timestamp accuracy
✅ Provides 100x more data density than Dataflux marker polling
✅ Requires minimal code changes to existing codebase
✅ Is immediately implementable

The key limitation is that timestamps represent **data receipt time** rather than **instrument measurement time**, with ~1-5ms variable latency. This is consistent with how the Dataflux reference system operates on the Keysight E5063A.

For applications requiring true measurement timestamps, firmware-level modification would be necessary (not currently available in LibreVNA).

---

**Document Version:** 1.0
**Last Updated:** 2026-02-11
**Author:** LibreVNA Python Expert Agent
**Review Status:** Ready for Implementation
